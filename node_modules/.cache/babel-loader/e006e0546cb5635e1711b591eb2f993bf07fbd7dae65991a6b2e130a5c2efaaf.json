{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport NumberType from '../../types/Number.js';\nimport StringType from '../../types/String.js';\nimport BooleanType from '../../types/Boolean.js';\nimport DateType from '../../types/Date.js';\nvar DEFAULT_OPTIONS = {\n  schemaPropertyValueForMissingColumn: undefined,\n  schemaPropertyValueForUndefinedCellValue: undefined,\n  schemaPropertyValueForNullCellValue: null,\n  schemaPropertyShouldSkipRequiredValidationForMissingColumn: function schemaPropertyShouldSkipRequiredValidationForMissingColumn() {\n    return false;\n  },\n  // `getEmptyObjectValue(object, { path })` applies to both the top-level object\n  // and any of its sub-objects.\n  getEmptyObjectValue: function getEmptyObjectValue() {\n    return null;\n  },\n  getEmptyArrayValue: function getEmptyArrayValue() {\n    return null;\n  },\n  isColumnOriented: false,\n  arrayValueSeparator: ','\n};\n\n/**\r\n * (this function is exported from `read-excel-file/map`)\r\n * Converts spreadsheet-alike data structure into an array of objects.\r\n * The first row should be the list of column headers.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @param {object} [options]\r\n * @param {null} [options.schemaPropertyValueForMissingColumn] — By default, when some of the `schema` columns are missing in the input `data`, those properties are set to `undefined` in the output objects. Pass `schemaPropertyValueForMissingColumn: null` to set such \"missing column\" properties to `null` in the output objects.\r\n * @param {null} [options.schemaPropertyValueForNullCellValue] — By default, when it encounters a `null` value in a cell in input `data`, it sets it to `undefined` in the output object. Pass `schemaPropertyValueForNullCellValue: null` to make it set such values as `null`s in output objects.\r\n * @param {null} [options.schemaPropertyValueForUndefinedCellValue] — By default, when it encounters an `undefined` value in a cell in input `data`, it it sets it to `undefined` in the output object. Pass `schemaPropertyValueForUndefinedCellValue: null` to make it set such values as `null`s in output objects.\r\n * @param {boolean} [options.schemaPropertyShouldSkipRequiredValidationForMissingColumn(column: string, { object })] — By default, it does apply `required` validation to `schema` properties for which columns are missing in the input `data`. One could pass a custom `schemaPropertyShouldSkipRequiredValidationForMissingColumn(column, { object })` to disable `required` validation for missing columns in some or all cases.\r\n * @param {function} [options.getEmptyObjectValue(object, { path })] — By default, it returns `null` for an \"empty\" resulting object. One could override that value using `getEmptyObjectValue(object, { path })` parameter. The value applies to both top-level object and any nested sub-objects in case of a nested schema, hence the additional `path?: string` parameter.\r\n * @param {function} [getEmptyArrayValue(array, { path })] — By default, it returns `null` for an \"empty\" array value. One could override that value using `getEmptyArrayValue(array, { path })` parameter.\r\n * @param {boolean} [options.isColumnOriented] — By default, the headers are assumed to be the first row in the `data`. Pass `isColumnOriented: true` if the headers are the first column in the `data`. i.e. if `data` is \"transposed\".\r\n * @param {object} [options.rowIndexMap] — Custom row index mapping `data` rows. If present, will overwrite the indexes of `data` rows with the indexes from this `rowIndexMap`.\r\n * @return {object[]}\r\n */\nexport default function mapToObjects(data, schema, options) {\n  if (options) {\n    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n  var _options = options,\n    isColumnOriented = _options.isColumnOriented,\n    rowIndexMap = _options.rowIndexMap;\n  validateSchema(schema);\n  if (isColumnOriented) {\n    data = transpose(data);\n  }\n  var columns = data[0];\n  var results = [];\n  var errors = [];\n  for (var i = 1; i < data.length; i++) {\n    var result = read(schema, data[i], i, undefined, columns, errors, options);\n    results.push(result);\n  }\n\n  // Set the correct `row` number in `errors` if a custom `rowIndexMap` is supplied.\n  if (rowIndexMap) {\n    for (var _iterator = _createForOfIteratorHelperLoose(errors), _step; !(_step = _iterator()).done;) {\n      var error = _step.value;\n      // Convert the `row` index in `data` to the\n      // actual `row` index in the spreadsheet.\n      // `- 1` converts row number to row index.\n      // `+ 1` converts row index to row number.\n      error.row = rowIndexMap[error.row - 1] + 1;\n    }\n  }\n  return {\n    rows: results,\n    errors: errors\n  };\n}\nfunction read(schema, row, rowIndex, path, columns, errors, options) {\n  var object = {};\n  var isEmptyObject = true;\n  var createError = function createError(_ref) {\n    var column = _ref.column,\n      value = _ref.value,\n      errorMessage = _ref.error,\n      reason = _ref.reason;\n    var error = {\n      error: errorMessage,\n      row: rowIndex + 1,\n      column: column,\n      value: value\n    };\n    if (reason) {\n      error.reason = reason;\n    }\n    if (schema[column].type) {\n      error.type = schema[column].type;\n    }\n    return error;\n  };\n  var pendingRequiredChecks = [];\n\n  // For each schema entry.\n  var _loop = function _loop() {\n    var key = _Object$keys[_i];\n    var schemaEntry = schema[key];\n    var isNestedSchema = _typeof(schemaEntry.type) === 'object' && !Array.isArray(schemaEntry.type);\n\n    // The path of this property inside the resulting object.\n    var propertyPath = \"\".concat(path || '', \".\").concat(schemaEntry.prop);\n\n    // Read the cell value for the schema entry.\n    var cellValue;\n    var columnIndex = columns.indexOf(key);\n    var isMissingColumn = columnIndex < 0;\n    if (!isMissingColumn) {\n      cellValue = row[columnIndex];\n    }\n    var value;\n    var error;\n    var reason;\n\n    // Get property `value` from cell value.\n    if (isNestedSchema) {\n      value = read(schemaEntry.type, row, rowIndex, propertyPath, columns, errors, options);\n    } else {\n      if (isMissingColumn) {\n        value = options.schemaPropertyValueForMissingColumn;\n      } else if (cellValue === undefined) {\n        value = options.schemaPropertyValueForUndefinedCellValue;\n      } else if (cellValue === null) {\n        value = options.schemaPropertyValueForNullCellValue;\n      } else if (Array.isArray(schemaEntry.type)) {\n        var array = parseArray(cellValue, options.arrayValueSeparator).map(function (_value) {\n          if (error) {\n            return;\n          }\n          var result = parseValue(_value, schemaEntry, options);\n          if (result.error) {\n            // In case of an error, `value` won't be returned and will just be reported\n            // as part of an `error` object, so it's fine assigning just an element of the array.\n            value = _value;\n            error = result.error;\n            reason = result.reason;\n          }\n          return result.value;\n        });\n        if (!error) {\n          var isEmpty = array.every(isEmptyValue);\n          value = isEmpty ? options.getEmptyArrayValue(array, {\n            path: propertyPath\n          }) : array;\n        }\n      } else {\n        var result = parseValue(cellValue, schemaEntry, options);\n        error = result.error;\n        reason = result.reason;\n        value = error ? cellValue : result.value;\n      }\n    }\n\n    // Apply `required` validation if the value is \"empty\".\n    if (!error && isEmptyValue(value)) {\n      if (schemaEntry.required) {\n        // Will perform this `required()` validation in the end,\n        // when all properties of the mapped object have been mapped.\n        pendingRequiredChecks.push({\n          column: key,\n          value: value,\n          isMissingColumn: isMissingColumn\n        });\n      }\n    }\n    if (error) {\n      // If there was an error then the property value in the `object` will be `undefined`,\n      // i.e it won't add the property value to the mapped object.\n      errors.push(createError({\n        column: key,\n        value: value,\n        error: error,\n        reason: reason\n      }));\n    } else {\n      // Possibly unmark the mapped object as \"empty\".\n      if (isEmptyObject && !isEmptyValue(value)) {\n        isEmptyObject = false;\n      }\n      // Set the value in the mapped object.\n      // Skip setting `undefined` values because they're already `undefined`.\n      if (value !== undefined) {\n        object[schemaEntry.prop] = value;\n      }\n    }\n  };\n  for (var _i = 0, _Object$keys = Object.keys(schema); _i < _Object$keys.length; _i++) {\n    _loop();\n  }\n\n  // Return `null` for an \"empty\" mapped object.\n  if (isEmptyObject) {\n    return options.getEmptyObjectValue(object, {\n      path: path\n    });\n  }\n\n  // Perform any `required` validations.\n  for (var _i2 = 0, _pendingRequiredCheck = pendingRequiredChecks; _i2 < _pendingRequiredCheck.length; _i2++) {\n    var _pendingRequiredCheck2 = _pendingRequiredCheck[_i2],\n      column = _pendingRequiredCheck2.column,\n      value = _pendingRequiredCheck2.value,\n      isMissingColumn = _pendingRequiredCheck2.isMissingColumn;\n    // Can optionally skip `required` validation for missing columns.\n    var skipRequiredValidation = isMissingColumn && options.schemaPropertyShouldSkipRequiredValidationForMissingColumn(column, {\n      object: object\n    });\n    if (!skipRequiredValidation) {\n      var required = schema[column].required;\n      var isRequired = typeof required === 'boolean' ? required : required(object);\n      if (isRequired) {\n        errors.push(createError({\n          column: column,\n          value: value,\n          error: 'required'\n        }));\n      }\n    }\n  }\n\n  // Return the mapped object.\n  return object;\n}\n\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\nexport function parseValue(value, schemaEntry, options) {\n  if (value === null) {\n    return {\n      value: null\n    };\n  }\n  var result;\n  if (schemaEntry.parse) {\n    result = parseCustomValue(value, schemaEntry.parse);\n  } else if (schemaEntry.type) {\n    result = parseValueOfType(value,\n    // Supports parsing array types.\n    // See `parseArray()` function for more details.\n    // Example `type`: String[]\n    // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\n    // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\n    Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options);\n  } else {\n    result = {\n      value: value\n    };\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\n  }\n  // If errored then return the error.\n  if (result.error) {\n    return result;\n  }\n  if (result.value !== null) {\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\n      return {\n        error: 'invalid',\n        reason: 'unknown'\n      };\n    }\n    if (schemaEntry.validate) {\n      try {\n        schemaEntry.validate(result.value);\n      } catch (error) {\n        return {\n          error: error.message\n        };\n      }\n    }\n  }\n  return result;\n}\n\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\nfunction parseCustomValue(value, parse) {\n  try {\n    var parsedValue = parse(value);\n    if (parsedValue === undefined) {\n      return {\n        value: null\n      };\n    }\n    return {\n      value: parsedValue\n    };\n  } catch (error) {\n    var result = {\n      error: error.message\n    };\n    if (error.reason) {\n      result.reason = error.reason;\n    }\n    return result;\n  }\n}\n\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\nfunction parseValueOfType(value, type, options) {\n  switch (type) {\n    case String:\n      return parseCustomValue(value, StringType);\n    case Number:\n      return parseCustomValue(value, NumberType);\n    case Date:\n      return parseCustomValue(value, function (value) {\n        return DateType(value, {\n          properties: options.properties\n        });\n      });\n    case Boolean:\n      return parseCustomValue(value, BooleanType);\n    default:\n      if (typeof type === 'function') {\n        return parseCustomValue(value, type);\n      }\n      throw new Error(\"Unsupported schema type: \".concat(type && type.name || type));\n  }\n}\nexport function getBlock(string, endCharacter, startIndex) {\n  var i = 0;\n  var substring = '';\n  var character;\n  while (startIndex + i < string.length) {\n    var _character = string[startIndex + i];\n    if (_character === endCharacter) {\n      return [substring, i];\n    } else if (_character === '\"') {\n      var block = getBlock(string, '\"', startIndex + i + 1);\n      substring += block[0];\n      i += '\"'.length + block[1] + '\"'.length;\n    } else {\n      substring += _character;\n      i++;\n    }\n  }\n  return [substring, i];\n}\n\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\nexport function parseArray(string, arrayValueSeparator) {\n  var blocks = [];\n  var index = 0;\n  while (index < string.length) {\n    var _getBlock = getBlock(string, arrayValueSeparator, index),\n      _getBlock2 = _slicedToArray(_getBlock, 2),\n      substring = _getBlock2[0],\n      length = _getBlock2[1];\n    index += length + arrayValueSeparator.length;\n    blocks.push(substring.trim());\n  }\n  return blocks;\n}\n\n// Transpose a 2D array.\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\nvar transpose = function transpose(array) {\n  return array[0].map(function (_, i) {\n    return array.map(function (row) {\n      return row[i];\n    });\n  });\n};\nfunction validateSchema(schema) {\n  for (var _i3 = 0, _Object$keys2 = Object.keys(schema); _i3 < _Object$keys2.length; _i3++) {\n    var key = _Object$keys2[_i3];\n    var entry = schema[key];\n    if (!entry.prop) {\n      throw new Error(\"\\\"prop\\\" not defined for schema entry \\\"\".concat(key, \"\\\".\"));\n    }\n  }\n}\nfunction isEmptyValue(value) {\n  return value === undefined || value === null;\n}","map":{"version":3,"names":["NumberType","StringType","BooleanType","DateType","DEFAULT_OPTIONS","schemaPropertyValueForMissingColumn","undefined","schemaPropertyValueForUndefinedCellValue","schemaPropertyValueForNullCellValue","schemaPropertyShouldSkipRequiredValidationForMissingColumn","getEmptyObjectValue","getEmptyArrayValue","isColumnOriented","arrayValueSeparator","mapToObjects","data","schema","options","_objectSpread","_options","rowIndexMap","validateSchema","transpose","columns","results","errors","i","length","result","read","push","_iterator","_createForOfIteratorHelperLoose","_step","done","error","value","row","rows","rowIndex","path","object","isEmptyObject","createError","_ref","column","errorMessage","reason","type","pendingRequiredChecks","_loop","key","_Object$keys","_i","schemaEntry","isNestedSchema","_typeof","Array","isArray","propertyPath","concat","prop","cellValue","columnIndex","indexOf","isMissingColumn","array","parseArray","map","_value","parseValue","isEmpty","every","isEmptyValue","required","Object","keys","_i2","_pendingRequiredCheck","_pendingRequiredCheck2","skipRequiredValidation","isRequired","parse","parseCustomValue","parseValueOfType","oneOf","validate","message","parsedValue","String","Number","Date","properties","Boolean","Error","name","getBlock","string","endCharacter","startIndex","substring","character","_character","block","blocks","index","_getBlock","_getBlock2","_slicedToArray","trim","_","_i3","_Object$keys2","entry"],"sources":["/Users/thitipongleelajelawat/INC34_MONEYMAG/student-payment-app/node_modules/read-excel-file/source/read/schema/mapToObjects.js"],"sourcesContent":["import NumberType from '../../types/Number.js'\r\nimport StringType from '../../types/String.js'\r\nimport BooleanType from '../../types/Boolean.js'\r\nimport DateType from '../../types/Date.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  schemaPropertyValueForMissingColumn: undefined,\r\n  schemaPropertyValueForUndefinedCellValue: undefined,\r\n  schemaPropertyValueForNullCellValue: null,\r\n  schemaPropertyShouldSkipRequiredValidationForMissingColumn: () => false,\r\n  // `getEmptyObjectValue(object, { path })` applies to both the top-level object\r\n  // and any of its sub-objects.\r\n  getEmptyObjectValue: () => null,\r\n  getEmptyArrayValue: () => null,\r\n  isColumnOriented: false,\r\n  arrayValueSeparator: ','\r\n}\r\n\r\n/**\r\n * (this function is exported from `read-excel-file/map`)\r\n * Converts spreadsheet-alike data structure into an array of objects.\r\n * The first row should be the list of column headers.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @param {object} [options]\r\n * @param {null} [options.schemaPropertyValueForMissingColumn] — By default, when some of the `schema` columns are missing in the input `data`, those properties are set to `undefined` in the output objects. Pass `schemaPropertyValueForMissingColumn: null` to set such \"missing column\" properties to `null` in the output objects.\r\n * @param {null} [options.schemaPropertyValueForNullCellValue] — By default, when it encounters a `null` value in a cell in input `data`, it sets it to `undefined` in the output object. Pass `schemaPropertyValueForNullCellValue: null` to make it set such values as `null`s in output objects.\r\n * @param {null} [options.schemaPropertyValueForUndefinedCellValue] — By default, when it encounters an `undefined` value in a cell in input `data`, it it sets it to `undefined` in the output object. Pass `schemaPropertyValueForUndefinedCellValue: null` to make it set such values as `null`s in output objects.\r\n * @param {boolean} [options.schemaPropertyShouldSkipRequiredValidationForMissingColumn(column: string, { object })] — By default, it does apply `required` validation to `schema` properties for which columns are missing in the input `data`. One could pass a custom `schemaPropertyShouldSkipRequiredValidationForMissingColumn(column, { object })` to disable `required` validation for missing columns in some or all cases.\r\n * @param {function} [options.getEmptyObjectValue(object, { path })] — By default, it returns `null` for an \"empty\" resulting object. One could override that value using `getEmptyObjectValue(object, { path })` parameter. The value applies to both top-level object and any nested sub-objects in case of a nested schema, hence the additional `path?: string` parameter.\r\n * @param {function} [getEmptyArrayValue(array, { path })] — By default, it returns `null` for an \"empty\" array value. One could override that value using `getEmptyArrayValue(array, { path })` parameter.\r\n * @param {boolean} [options.isColumnOriented] — By default, the headers are assumed to be the first row in the `data`. Pass `isColumnOriented: true` if the headers are the first column in the `data`. i.e. if `data` is \"transposed\".\r\n * @param {object} [options.rowIndexMap] — Custom row index mapping `data` rows. If present, will overwrite the indexes of `data` rows with the indexes from this `rowIndexMap`.\r\n * @return {object[]}\r\n */\r\nexport default function mapToObjects(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowIndexMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i, undefined, columns, errors, options)\r\n    results.push(result)\r\n  }\r\n\r\n  // Set the correct `row` number in `errors` if a custom `rowIndexMap` is supplied.\r\n  if (rowIndexMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // `- 1` converts row number to row index.\r\n      // `+ 1` converts row index to row number.\r\n      error.row = rowIndexMap[error.row - 1] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, path, columns, errors, options) {\r\n  const object = {}\r\n  let isEmptyObject = true\r\n\r\n  const createError = ({\r\n    column,\r\n    value,\r\n    error: errorMessage,\r\n    reason\r\n  }) => {\r\n    const error = {\r\n      error: errorMessage,\r\n      row: rowIndex + 1,\r\n      column,\r\n      value\r\n    }\r\n    if (reason) {\r\n      error.reason = reason\r\n    }\r\n    if (schema[column].type) {\r\n      error.type = schema[column].type\r\n    }\r\n    return error\r\n  }\r\n\r\n  const pendingRequiredChecks = []\r\n\r\n  // For each schema entry.\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n\r\n    // The path of this property inside the resulting object.\r\n    const propertyPath = `${path || ''}.${schemaEntry.prop}`\r\n\r\n    // Read the cell value for the schema entry.\r\n    let cellValue\r\n    const columnIndex = columns.indexOf(key)\r\n    const isMissingColumn = columnIndex < 0\r\n    if (!isMissingColumn) {\r\n      cellValue = row[columnIndex]\r\n    }\r\n\r\n    let value\r\n    let error\r\n    let reason\r\n\r\n    // Get property `value` from cell value.\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, propertyPath, columns, errors, options)\r\n    } else {\r\n      if (isMissingColumn) {\r\n        value = options.schemaPropertyValueForMissingColumn\r\n      }\r\n      else if (cellValue === undefined) {\r\n        value = options.schemaPropertyValueForUndefinedCellValue\r\n      }\r\n      else if (cellValue === null) {\r\n        value = options.schemaPropertyValueForNullCellValue\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        const array = parseArray(cellValue, options.arrayValueSeparator).map((_value) => {\r\n          if (error) {\r\n            return\r\n          }\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            // In case of an error, `value` won't be returned and will just be reported\r\n            // as part of an `error` object, so it's fine assigning just an element of the array.\r\n            value = _value\r\n            error = result.error\r\n            reason = result.reason\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          const isEmpty = array.every(isEmptyValue)\r\n          value = isEmpty ? options.getEmptyArrayValue(array, { path: propertyPath }) : array\r\n        }\r\n      } else {\r\n        const result = parseValue(cellValue, schemaEntry, options)\r\n        error = result.error\r\n        reason = result.reason\r\n        value = error ? cellValue : result.value\r\n      }\r\n    }\r\n\r\n    // Apply `required` validation if the value is \"empty\".\r\n    if (!error && isEmptyValue(value)) {\r\n      if (schemaEntry.required) {\r\n        // Will perform this `required()` validation in the end,\r\n        // when all properties of the mapped object have been mapped.\r\n        pendingRequiredChecks.push({ column: key, value, isMissingColumn })\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      // If there was an error then the property value in the `object` will be `undefined`,\r\n      // i.e it won't add the property value to the mapped object.\r\n      errors.push(createError({\r\n        column: key,\r\n        value,\r\n        error,\r\n        reason\r\n      }))\r\n    } else {\r\n      // Possibly unmark the mapped object as \"empty\".\r\n      if (isEmptyObject && !isEmptyValue(value)) {\r\n        isEmptyObject = false\r\n      }\r\n      // Set the value in the mapped object.\r\n      // Skip setting `undefined` values because they're already `undefined`.\r\n      if (value !== undefined) {\r\n        object[schemaEntry.prop] = value\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return `null` for an \"empty\" mapped object.\r\n  if (isEmptyObject) {\r\n    return options.getEmptyObjectValue(object, { path })\r\n  }\r\n\r\n  // Perform any `required` validations.\r\n  for (const { column, value, isMissingColumn } of pendingRequiredChecks) {\r\n    // Can optionally skip `required` validation for missing columns.\r\n    const skipRequiredValidation = isMissingColumn && options.schemaPropertyShouldSkipRequiredValidationForMissingColumn(column, { object })\r\n    if (!skipRequiredValidation) {\r\n      const { required } = schema[column]\r\n      const isRequired = typeof required === 'boolean' ? required : required(object)\r\n      if (isRequired) {\r\n        errors.push(createError({\r\n          column,\r\n          value,\r\n          error: 'required'\r\n        }))\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return the mapped object.\r\n  return object\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(\r\n      value,\r\n      // Supports parsing array types.\r\n      // See `parseArray()` function for more details.\r\n      // Example `type`: String[]\r\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\r\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\r\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\r\n      options\r\n    )\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid', reason: 'unknown' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    const parsedValue = parse(value)\r\n    if (parsedValue === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value: parsedValue }\r\n  } catch (error) {\r\n    const result = { error: error.message }\r\n    if (error.reason) {\r\n      result.reason = error.reason;\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return parseCustomValue(value, StringType)\r\n\r\n    case Number:\r\n      return parseCustomValue(value, NumberType)\r\n\r\n    case Date:\r\n      return parseCustomValue(value, (value) => DateType(value, { properties: options.properties }))\r\n\r\n    case Boolean:\r\n      return parseCustomValue(value, BooleanType)\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unsupported schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\r\nexport function parseArray(string, arrayValueSeparator) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, arrayValueSeparator, index)\r\n    index += length + arrayValueSeparator.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction isEmptyValue(value) {\r\n  return value === undefined || value === null\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}